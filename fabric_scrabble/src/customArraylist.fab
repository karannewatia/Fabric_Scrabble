package fabricated.util;

public class customArrayList[label L1, label L2] extends AbstractList[L2] implements List[L2], RandomAccess
{
  /**
   * The default capacity for new ArrayLists.
   */
  private static final int{*<-} DEFAULT_CAPACITY = 10;

  /**
   * The number of elements in this list.
   * @serial the list size
   */
  private int{L2} size;

  /**
   * Where the data is stored.
   */
  private final Object{L2}[]{L1} data;

  /**
   * Construct a new ArrayList with the supplied initial capacity.
   *
   * @param capacity initial capacity of this ArrayList
   * @throws IllegalArgumentException if capacity is negative
   */
  public customArrayList{L2}(Comparator[L2]{L2} compare, int{L2} capacity) throws (IllegalArgumentException{L2})
  {
    // Must explicitly check, to get correct exception.
    if (capacity < 0)
      throw new IllegalArgumentException();
    data = new Object[capacity];
    super(compare);
  }

  /**
 * Construct a new ArrayList with the default capacity (16).
 */
  public customArrayList{L2}(Comparator[L2]{L2} compare) throws (IllegalArgumentException{L2})
  {
    this(compare,DEFAULT_CAPACITY);
  }

  /**
   * Guarantees that this list will have at least enough capacity to
   * hold minCapacity elements. This implementation will grow the list to
   * max(current * 2, minCapacity) if (minCapacity &gt; current). The JCL says
   * explictly that "this method increases its capacity to minCap", while
   * the JDK 1.3 online docs specify that the list will grow to at least the
   * size specified.
   *
   * @param minCapacity the minimum guaranteed capacity
   */
  public void ensureCapacity{L2}(int{L2} minCapacity)
  {
    int{L2} current = data.length;
    if (minCapacity > current)
      data.length = (current * 2 > minCapacity) ? (current * 2) : minCapacity;
  }

  /**
   * Returns the number of elements in this list.
   *
   * @return the list size
   */
  public int{L2} size()
  {
    return size;
  }

  /**
   * Checks if the list is empty.
   *
   * @return true if there are no elements
   */
  public boolean{L2} isEmpty()
  {
    return size == 0;
  }

  /**
   * Retrieves the element at the user-supplied index.
   *
   * @param index the index of the element we are fetching
   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()
   */
  public Object{L2} get{L2}(int{L2} index) throws (IndexOutOfBoundsException{L2})
  {
    checkBoundExclusive(index);
    return data[index];
  }

  /**
  * Appends the supplied element to the end of this list.
  * The element, e, can be an object of any type or null.
  *
  * @param e the element to be appended to this list
  * @return true, the add will always succeed
  */
 public boolean{L2} add{L2}(Object{L2} e) throws (UnsupportedOperationException{L2},
     ClassCastException{L2}, NullPointerException{L2}, IllegalArgumentException{L2})
 {
   modCount++;
   if (size == data.length)
     ensureCapacity(size + 1);
   data[size++] = e;
   return true;
 }

 /**
   * Removes the element at the user-supplied index.
   *
   * @param index the index of the element to be removed
   * @return the removed Object
   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()
   */
  public Object{L2} remove{L2}(int{L2} index) throws (UnsupportedOperationException{L2},
      IndexOutOfBoundsException{L2})
  {
    checkBoundExclusive(index);
    Object r = data[index];
    modCount++;
    if (index != --size)
      Arrays.arraycopy(L2, data, index + 1, data, index, size - index);
    // Aid for garbage collection by releasing this pointer.
    data[size] = null;
    return r;
  }

  /**
   * Checks that the index is in the range of existing elements (exclusive).
   *
   * @param index the index to check
   * @throws IndexOutOfBoundsException if index &gt;= size
   */
  private void checkBoundExclusive{L2}(int{L2} index) throws (IndexOutOfBoundsException{L2})
  {
    // Implementation note: we do not check for negative ranges here, since
    // use of a negative index will cause an ArrayIndexOutOfBoundsException,
    // a subclass of the required exception, with no effort on our part.
    if (index >= size)
      throw new IndexOutOfBoundsException("Index: " + index + ", Size: "
                                          + size);
  }


}
