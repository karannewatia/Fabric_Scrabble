package fabricated.util;

public class customArrayList[label L1, label L2] extends AbstractList[L1] implements List[L1], RandomAccess
{
  /**
   * The default capacity for new ArrayLists.
   */
  private static final int{*<-} DEFAULT_CAPACITY = 10;

  /**
   * The number of elements in this list.
   * @serial the list size
   */
  private int{L1} size;

  /**
   * Where the data is stored.
   */
  private final Object{L2}[]{L1} data;
  /**
   * Construct a new ArrayList with the supplied initial capacity.
   *
   * @param capacity initial capacity of this ArrayList
   * @throws IllegalArgumentException if capacity is negative
   */
  public customArrayList{L1}(Comparator[L2]{L2} compare, int{L1} capacity) throws (IllegalArgumentException)
  {
    // Must explicitly check, to get correct exception.
    if (capacity < 0)
      throw new IllegalArgumentException();
    data = new Object[capacity];
    super(compare);
  }

  /**
 * Construct a new ArrayList with the default capacity (16).
 */
  public customArrayList{L1}(Comparator[L2]{L2} compare) throws (IllegalArgumentException)
  {
    this(compare,DEFAULT_CAPACITY);
  }

  /**
   * Construct a new ArrayList, and initialize it with the elements
   * in the supplied Collection. The initial capacity is 110% of the
   * Collection's size.
   *
   * @param c the collection whose elements will initialize this list
   * @throws NullPointerException if c is null
   */
  public customArrayList{L1}(Comparator[L2]{L2} compare, Collection[L1]{L1} c)
      throws (IllegalArgumentException{L1}, ClassCastException{L1}, NullPointerException{L1})
  {
    this(compare,(int) (c.size() * 1.1f));
    try {
      addAll(c);
    } catch (UnsupportedOperationException{L1} uoe) {
    } catch (IllegalStateException{L1} ise) {
    }
  }

  /**
   * Trims the capacity of this List to be equal to its size;
   * a memory saver.
   */
  public void trimToSize{L1}()
  {
    // Not a structural change from the perspective of iterators on this list,
    // so don't update modCount.
    data.length = size;
  }

  /**
   * Returns the number of elements in this list.
   *
   * @return the list size
   */
  public int{L1} size()
  {
    return size;
  }

  /**
   * Checks if the list is empty.
   *
   * @return true if there are no elements
   */
  public boolean{L1} isEmpty()
  {
    return size == 0;
  }

  /**
 * Returns true iff element is in this ArrayList.
 *
 * @param e the element whose inclusion in the List is being tested
 * @return true if the list contains e
 */
  public boolean{L1} contains{L1}(Object{L2} e) throws (ClassCastException{L1}, NullPointerException{L1})
  {
    return indexOf(e) != -1;
  }

  /**
   * Returns the lowest index at which element appears in this List, or
   * -1 if it does not appear.
   *
   * @param e the element whose inclusion in the List is being tested
   * @return the index where e was found
   */
  public int{L1} indexOf{L1}(Object{L2} e) throws (ClassCastException{L1}, NullPointerException{L1})
  {
    for (int i = 0; i < size; i++)
      if (compare.equals(e, data[i]))
        return i;
    return -1;
  }

  /**
   * Retrieves the element at the user-supplied index.
   *
   * @param index the index of the element we are fetching
   * @throws IndexOutOfBoundsException if index &lt; 0 || index &gt;= size()
   */
  public Object{L2} get{L1}(int{L1} index) throws (IndexOutOfBoundsException{L1})
  {
    checkBoundExclusive(index);
    return data[index];
  }



}
