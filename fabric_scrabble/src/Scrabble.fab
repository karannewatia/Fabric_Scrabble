import fabricated.util.ArrayList;
import fabricated.util.StringComparator;
import fabric.util.PrintString;

import fabfx.application.Application;
import fabfx.stage.Stage;
import fabfx.scene.*;
import fabfx.scene.layout.*;
import fabfx.scene.text.Text;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import fabfx.event.Event;
import fabfx.event.EventHandler;
import fabfx.scene.input.KeyEvent;
import javafx.scene.input.KeyCode;

/**
 * The class Scrabble is responsible for coordinating gameplay
 * between two Players.
 */
public class Scrabble[principal Game, principal allPlayers] authority(Game) {

  private ArrayList[{Game<-}]{Game<-} players;
  //private ArrayList[{Game<-}]{Game<-} playerPrincipals;
  private ArrayList[{Game<-}]{Game<-} playerScores;
  private ArrayList[{Game<-}]{Game<-} playerTilesLeft;

  private Bag[Game]{Game<-} bag;
  private int{Game<-} currentPlayer;
  private Board[Game, allPlayers]{Game<-} board;

  public Scrabble{Game<-}(ArrayList[{Game<-}]{Game<-} playersList,
                       // ArrayList[{Game<-}]{Game<-} playerPrincipalsList,
                        ArrayList[{Game<-}]{Game<-} playerScoresList, ArrayList[{Game<-}]{Game<-} playerTilesLeftList){

    this.bag = new Bag{Game<-}();
    this.board = new Board{Game<-}();
    this.currentPlayer = 0;
    this.players = playersList;
    //this.playerPrincipals = playerPrincipalsList;
    this.playerScores = playerScoresList;
    this.playerTilesLeft =  playerTilesLeftList;
  }

  /**
  * Initializes the Bag, and the racks of all players in this Scrabble game
  */
  public void startGame{Game<-}(){
    atomic{
      this.bag.populateBag();
      for(int i=0; i<this.players.size();i++){
        ((Player) this.players.get(i)).rack.populateRackTile(this.bag);
      }
    }
  }

  /**
  * Returns true if the current player has an empty rack,
  * and false otherwise
  */
  public boolean{Game<-} emptyRack{Game<-}() {
     boolean{Game<-} result = false;
     Integer tilesLeft = (Integer)this.playerTilesLeft.get(this.currentPlayer);

      if (tilesLeft.intValue() == 0){
        result = true;
        return result;
      }
     return result;
  }

  /**
  * Returns the player who has the highest score,
  */
  public int{} getWinner{Game<-}() {
     int winner = 0;
     int highScore = 0;
     Integer score0 = (Integer)this.playerScores.get(0);
     highScore = score0.intValue();

     for (int i=1; i<this.playerScores.size(); i++){
        //final principal pr =  (Principal)this.playerPrincipals.get(i);
        //Player{Game<-} p = (Player[Game, pr])this.players.get(i);

        Integer temp = (Integer)this.playerScores.get(i);
        int score = temp.intValue();
        if(score > highScore){
          highScore = score;
          winner = i;
        }
     }
     return winner;
  }

  /**
  * helper function for the swap move for a player
  */
  public boolean swap(principal Player){
    boolean success = false;

    //String{Game<-} word = this.swap_gui();
    //String[] letters = this.stringToStringArray(word);
    String[]{Game<-; Game->Player} letters = new String[1];
    atomic{
      //((Player) this.players.get(this.currentPlayer)).rack.swapTiles(letters, this.bag);
      success = true;
      return success;
    }
  }

  /**
  * Helper function move.
  * calls the relevant functions using moveType
  */
  public boolean moveHelper(String moveType){
    boolean success = false;
    atomic{
      if (moveType.equals("swap")){
        //return this.swap();
        return success;
      }
      else if (moveType.equals("place")){
        //return this.place();
        return success;
      }
      else if (moveType.equals("pass")){
        success = true;
        //System.out.println("turn passed");
        return success;
      }
    }
    //System.out.println("try again");
    return success;

  }

  /**
  * This functions asks the user to enter the type of move he/she wants to play.
  */
  public boolean move(){
    //this.readBoard(this.currentPlayer);
    //String moveType = this.move_gui();
    boolean result = false;
    String moveType = "";

    if (moveType==null){
      return result;
     }
    if (moveHelper(moveType)==true){
       //this.print_helper();
       result = true;
       return result;
     }
    return result;
  }

  /**
  * Prints the game board for every turn
  */
  public String{Game<-} readBoard{Game<-}(){
    String{Game<-} printBoard = "";
    atomic{
      printBoard += "\n";
      printBoard += "  "; //beginning 2 spaces
      for(int i = 0; i < this.board.gameBoard.length; ++i){
        if(i>9) printBoard += " " + (i) + " "; //print letters separately.
        else printBoard += " " + (i) +"  "; //print letters separately.
      }
      for(int i = 0; i < this.board.gameBoard.length; i++){
        printBoard += "\n";
        for(int j = 0; j < this.board.gameBoard.length; j++){
            if(j == 0){
                if(i>9) {
                  printBoard += i;
                  printBoard += "| ";
                } else {
                  printBoard += " " + i;
                  printBoard += "| ";
                }
            }
            printBoard += (String)(this.board.gameBoard[i].get(j)) + " | ";
          }
        }
        printBoard += "\n" + "\n" + "Player " + this.currentPlayer + "'s turn \n";
        printBoard += "Your score: " + ((Integer)this.playerScores.get(this.currentPlayer)).intValue() + "\n";
        //printBoard += "Your rack: " + ((Player)this.players.get(this.currentPlayer)).getRack() + "\n";

    }
      return printBoard;
  }

  public boolean{Game<-} moveHandler{Game<-} (Event[{Game<-}]{Game<-} ev_) {
    boolean success = false;
		atomic {
			if (ev_ instanceof KeyEvent[{Game<-}]) {
				KeyEvent[{Game<-}] ev = (KeyEvent[{Game<-}]) ev_;
				if (ev.getEventType() == KeyEvent.KEY_PRESSED) {
					KeyCode key = ev.getCode();
					if (key == KeyCode.P) {
						//return this.place;
            return success;
					} else if (key == KeyCode.S) {
						return success;
					} else {
					//pass;
          success = true;
          return success;
					}
				}
				ev_.consume();
			}
		}
	}

  /**
  * Runs the Scrabble game
  * the game ends when the number of moves played is equal to 50
  */
  public void gameLoop{Game<-}(){
    atomic{
      while(this.board.moveNumber < 50){
        //PrintString[{Game<-}]{Game<-} p = new PrintString[{Game<-}]();
        //p.print(this.readBoard());

        //new Gui().launchApp();

        boolean success = false;
        RemoteWorker w1  = ((Player)this.players.get(this.currentPlayer)).w;
        RemoteWorker w2  = ((Player)this.players.get((this.currentPlayer + 1) % this.players.size())).w;

       while (!success){
         // Remote call
          int temp = (this.currentPlayer + 1) % this.players.size();
          //this.readBoard_remote@w2(Worker.getWorker().getPrincipal(), temp);
          //success = this.move_remote@w1(Worker.getWorker().getPrincipal());
       }
       if (this.emptyRack()){
          int winner = this.getWinner();
          //System.out.println("The winner is player " + (winner) );
          break;
       }
       this.currentPlayer = (this.currentPlayer + 1) % this.players.size();
    }
    int winner = this.getWinner();
    //System.out.println("The winner is player " + (winner) );
    }
  }

}
