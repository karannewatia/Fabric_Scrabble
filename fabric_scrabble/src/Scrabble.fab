import fabricated.util.ArrayList;
import fabricated.util.StringComparator;

/**
 * The class Scrabble is responsible for coordinating gameplay
 * between two Players.
 */
public class Scrabble[principal Game, principal allPlayers] {

  private ArrayList[{Game<-}]{Game<-} players;
  private final ArrayList[{Game<-}]{Game<-} playerPrincipals;

  private Bag[Game]{Game<-} bag;
  private int{Game<-} currentPlayer;
  private Board[Game, allPlayers]{Game<-} board;

  public Scrabble{Game<-}(ArrayList[{Game<-}]{Game<-} playersList, ArrayList[{Game<-}]{Game<-} playerPrincipalsList){
    this.bag = new Bag{Game<-}();
    this.board = new Board{Game<-}();
    this.currentPlayer = 0;
    this.players = playersList;
    this.playerPrincipals = playerPrincipalsList;
  }

  /**
  * Initializes the Bag, and the racks of all players in this Scrabble game
  */
  public void startGame{Game<-}(){
    atomic{
      this.bag.populateBag();
      for(int i=0; i<this.players.size();i++){
        ((Player) this.players.get(i)).rack.populateRackTile(this.bag);
      }
    }
  }

  /**
  * Returns true if any player has an empty rack,
  * and false otherwise
  */
  public boolean{Game<-} emptyRack{Game<-} (){
     boolean{Game<-} result = false;
     for (int{Game<-} i=0; i<this.players.size(); i++){
        String{Game<-} flag = "";
        String{Game<-} blank = "";
        for (int{Game<-} j=0; j<7; j++){
          try{
            final principal pr =  (Principal)this.playerPrincipals.get(i);
            Player{Game<-} p = (Player[Game, pr])this.players.get(i);
            flag = flag + p.rack.tiles[j];
          }catch (Exception e){}


        }
        if (flag.equals(blank)){
          result = true;
          return result;
        }
     }
     return result;
  }


  /**
  * Returns the player who has the highest score,
  */
  public int getWinner{Game<-}() {
     int winner = 0;
     final principal pr0 =  (Principal)this.playerPrincipals.get(0);
     Player{Game<-} p = (Player[Game, pr0])this.players.get(0);
     if (p != null){
       int{Game<-} highScore = p.score;

       for (int i=1; i<this.players.size(); i++){
          Object{Game<-} ob = this.players.get(i);
          final principal pr =  (Principal)this.playerPrincipals.get(0);

          if (ob != null && pr != null){
            Player{Game<-} r = (Player[Game, pr])ob;
            int{Game<-} score = r.score;
            if(score > highScore){
              highScore = score;
              //winner = i;
            }
          }
       }
     }
     return winner;
  }

  /**
  * Runs the Scrabble game
  * the game ends when the number of moves played is equal to 50
  */
  public void gameLoop{Game<-}(){
    atomic{
      while(this.board.moveNumber < 50){
         if (this.emptyRack()){
            int{Game<-} winner = this.getWinner();
            //System.out.println("The winner is player " + (winner) );
            break;
         }
         else{
           //this.print_helper();
           boolean success = false;
           RemoteWorker w1  = ((Player)this.players.get(this.currentPlayer)).w;
           RemoteWorker w2  = ((Player)this.players.get((this.currentPlayer + 1) % this.players.size())).w;

           while (!success){
             // Remote call
              int temp = (this.currentPlayer + 1) % this.players.size();
              //this.readBoard_remote@w2(Worker.getWorker().getPrincipal(), temp);
              //success = this.move_remote@w1(Worker.getWorker().getPrincipal());
           }
          this.currentPlayer = (this.currentPlayer + 1) % this.players.size();
         }
      }
      int{Game<-} winner = this.getWinner();
      //System.out.println("The winner is player " + (winner) );
    }
  }

}
